/*
 * generated by Xtext 2.25.0
 */
package edu.upb.lp.isc.serializer;

import com.google.inject.Inject;
import edu.upb.lp.isc.compilacion.Aritmetica;
import edu.upb.lp.isc.compilacion.Atributo;
import edu.upb.lp.isc.compilacion.Bool;
import edu.upb.lp.isc.compilacion.Boolean_Op;
import edu.upb.lp.isc.compilacion.CompilacionPackage;
import edu.upb.lp.isc.compilacion.Equal;
import edu.upb.lp.isc.compilacion.FuncionSimplificada;
import edu.upb.lp.isc.compilacion.If;
import edu.upb.lp.isc.compilacion.Imprimible;
import edu.upb.lp.isc.compilacion.IsDataType;
import edu.upb.lp.isc.compilacion.List;
import edu.upb.lp.isc.compilacion.MyBool;
import edu.upb.lp.isc.compilacion.MyInt;
import edu.upb.lp.isc.compilacion.MyString;
import edu.upb.lp.isc.compilacion.NoImprimible;
import edu.upb.lp.isc.compilacion.Operadores;
import edu.upb.lp.isc.compilacion.Programa;
import edu.upb.lp.isc.compilacion.Variables;
import edu.upb.lp.isc.services.CompilacionGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class CompilacionSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private CompilacionGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == CompilacionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case CompilacionPackage.ARITMETICA:
				sequence_Aritmetica(context, (Aritmetica) semanticObject); 
				return; 
			case CompilacionPackage.ATRIBUTO:
				sequence_Atributo(context, (Atributo) semanticObject); 
				return; 
			case CompilacionPackage.BOOL:
				sequence_Bool(context, (Bool) semanticObject); 
				return; 
			case CompilacionPackage.BOOLEAN_OP:
				sequence_Boolean_Op(context, (Boolean_Op) semanticObject); 
				return; 
			case CompilacionPackage.EQUAL:
				sequence_Equal(context, (Equal) semanticObject); 
				return; 
			case CompilacionPackage.FUNCION_SIMPLIFICADA:
				sequence_FuncionSimplificada(context, (FuncionSimplificada) semanticObject); 
				return; 
			case CompilacionPackage.IF:
				sequence_If(context, (If) semanticObject); 
				return; 
			case CompilacionPackage.IMPRIMIBLE:
				sequence_Imprimible(context, (Imprimible) semanticObject); 
				return; 
			case CompilacionPackage.IS_DATA_TYPE:
				sequence_IsDataType(context, (IsDataType) semanticObject); 
				return; 
			case CompilacionPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case CompilacionPackage.MY_BOOL:
				sequence_MyBool(context, (MyBool) semanticObject); 
				return; 
			case CompilacionPackage.MY_INT:
				sequence_MyInt(context, (MyInt) semanticObject); 
				return; 
			case CompilacionPackage.MY_STRING:
				sequence_MyString(context, (MyString) semanticObject); 
				return; 
			case CompilacionPackage.NO_IMPRIMIBLE:
				sequence_NoImprimible(context, (NoImprimible) semanticObject); 
				return; 
			case CompilacionPackage.OPERADORES:
				sequence_Operadores(context, (Operadores) semanticObject); 
				return; 
			case CompilacionPackage.PROGRAMA:
				sequence_Programa(context, (Programa) semanticObject); 
				return; 
			case CompilacionPackage.VARIABLES:
				sequence_Variables(context, (Variables) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Ejecucion returns Aritmetica
	 *     Declaraciones returns Aritmetica
	 *     Simple returns Aritmetica
	 *     Expr returns Aritmetica
	 *     Aritmetica returns Aritmetica
	 *     Bloque returns Aritmetica
	 *
	 * Constraint:
	 *     (op=Operadores argument+=MyInt+)
	 */
	protected void sequence_Aritmetica(ISerializationContext context, Aritmetica semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Atributo returns Atributo
	 *
	 * Constraint:
	 *     atributoName=ID
	 */
	protected void sequence_Atributo(ISerializationContext context, Atributo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CompilacionPackage.Literals.ATRIBUTO__ATRIBUTO_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CompilacionPackage.Literals.ATRIBUTO__ATRIBUTO_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtributoAccess().getAtributoNameIDTerminalRuleCall_0(), semanticObject.getAtributoName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Bool returns Bool
	 *
	 * Constraint:
	 *     (
	 *         op='#T' | 
	 *         op='#F' | 
	 *         op='#t' | 
	 *         op='#f' | 
	 *         op='#true' | 
	 *         op='#false' | 
	 *         op='true' | 
	 *         op='false'
	 *     )
	 */
	protected void sequence_Bool(ISerializationContext context, Bool semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ejecucion returns Boolean_Op
	 *     Declaraciones returns Boolean_Op
	 *     Simple returns Boolean_Op
	 *     Expr returns Boolean_Op
	 *     Boolean_Op returns Boolean_Op
	 *     Equal returns Boolean_Op
	 *     Bloque returns Boolean_Op
	 *
	 * Constraint:
	 *     (op='<' | op='>=' | op='>' | op='<=')
	 */
	protected void sequence_Boolean_Op(ISerializationContext context, Boolean_Op semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ejecucion returns Equal
	 *     Declaraciones returns Equal
	 *     Simple returns Equal
	 *     Expr returns Equal
	 *     Equal returns Equal
	 *     Bloque returns Equal
	 *
	 * Constraint:
	 *     (n1=DataType_ n2=DataType_)
	 */
	protected void sequence_Equal(ISerializationContext context, Equal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CompilacionPackage.Literals.EQUAL__N1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CompilacionPackage.Literals.EQUAL__N1));
			if (transientValues.isValueTransient(semanticObject, CompilacionPackage.Literals.EQUAL__N2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CompilacionPackage.Literals.EQUAL__N2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualAccess().getN1DataType_ParserRuleCall_0_1_1_0(), semanticObject.getN1());
		feeder.accept(grammarAccess.getEqualAccess().getN2DataType_ParserRuleCall_0_1_2_0(), semanticObject.getN2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Ejecucion returns FuncionSimplificada
	 *     Declaraciones returns FuncionSimplificada
	 *     Simple returns FuncionSimplificada
	 *     Expr returns FuncionSimplificada
	 *     FuncionSimplificada returns FuncionSimplificada
	 *     Bloque returns FuncionSimplificada
	 *
	 * Constraint:
	 *     (name=ID atributo+=DataType_* then=Bloque)
	 */
	protected void sequence_FuncionSimplificada(ISerializationContext context, FuncionSimplificada semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaraciones returns If
	 *     Simple returns If
	 *     Estructuras returns If
	 *     If returns If
	 *     Bloque returns If
	 *
	 * Constraint:
	 *     (condition=Equal then=Bloque else=Bloque)
	 */
	protected void sequence_If(ISerializationContext context, If semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CompilacionPackage.Literals.IF__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CompilacionPackage.Literals.IF__CONDITION));
			if (transientValues.isValueTransient(semanticObject, CompilacionPackage.Literals.IF__THEN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CompilacionPackage.Literals.IF__THEN));
			if (transientValues.isValueTransient(semanticObject, CompilacionPackage.Literals.IF__ELSE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CompilacionPackage.Literals.IF__ELSE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIfAccess().getConditionEqualParserRuleCall_3_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getIfAccess().getThenBloqueParserRuleCall_6_0(), semanticObject.getThen());
		feeder.accept(grammarAccess.getIfAccess().getElseBloqueParserRuleCall_9_0(), semanticObject.getElse());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Imprimible returns Imprimible
	 *
	 * Constraint:
	 *     (var=[Variables|ID] | fun=[FuncionSimplificada|ID])
	 */
	protected void sequence_Imprimible(ISerializationContext context, Imprimible semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IsDataType returns IsDataType
	 *
	 * Constraint:
	 *     isType=DataType_
	 */
	protected void sequence_IsDataType(ISerializationContext context, IsDataType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CompilacionPackage.Literals.IS_DATA_TYPE__IS_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CompilacionPackage.Literals.IS_DATA_TYPE__IS_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIsDataTypeAccess().getIsTypeDataType_ParserRuleCall_2_0(), semanticObject.getIsType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Ejecucion returns List
	 *     Declaraciones returns List
	 *     Simple returns List
	 *     Expr returns List
	 *     DataType_ returns List
	 *     List returns List
	 *     LargoLista returns List
	 *     Bloque returns List
	 *
	 * Constraint:
	 *     typeOfList+=DataType_+
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ejecucion returns MyBool
	 *     Declaraciones returns MyBool
	 *     Simple returns MyBool
	 *     Expr returns MyBool
	 *     DataType_ returns MyBool
	 *     MyBool returns MyBool
	 *     Bloque returns MyBool
	 *
	 * Constraint:
	 *     value=Bool
	 */
	protected void sequence_MyBool(ISerializationContext context, MyBool semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CompilacionPackage.Literals.MY_BOOL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CompilacionPackage.Literals.MY_BOOL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMyBoolAccess().getValueBoolParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Ejecucion returns MyInt
	 *     Declaraciones returns MyInt
	 *     Simple returns MyInt
	 *     Expr returns MyInt
	 *     DataType_ returns MyInt
	 *     MyInt returns MyInt
	 *     Bloque returns MyInt
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_MyInt(ISerializationContext context, MyInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CompilacionPackage.Literals.MY_INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CompilacionPackage.Literals.MY_INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMyIntAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Ejecucion returns MyString
	 *     Declaraciones returns MyString
	 *     Simple returns MyString
	 *     Expr returns MyString
	 *     DataType_ returns MyString
	 *     MyString returns MyString
	 *     Bloque returns MyString
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_MyString(ISerializationContext context, MyString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CompilacionPackage.Literals.MY_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CompilacionPackage.Literals.MY_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMyStringAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NoImprimible returns NoImprimible
	 *
	 * Constraint:
	 *     (var=[Variables|ID] | fun=[FuncionSimplificada|ID])
	 */
	protected void sequence_NoImprimible(ISerializationContext context, NoImprimible semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operadores returns Operadores
	 *
	 * Constraint:
	 *     (
	 *         op='+' | 
	 *         op='-' | 
	 *         op='*' | 
	 *         op='/' | 
	 *         op='expt' | 
	 *         op='quotient' | 
	 *         op='remainder'
	 *     )
	 */
	protected void sequence_Operadores(ISerializationContext context, Operadores semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Programa returns Programa
	 *
	 * Constraint:
	 *     (name=ID declaraciones+=Declaraciones* ejecuciones+=Ejecucion*)
	 */
	protected void sequence_Programa(ISerializationContext context, Programa semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ejecucion returns Variables
	 *     Declaraciones returns Variables
	 *     Simple returns Variables
	 *     Expr returns Variables
	 *     Variables returns Variables
	 *     Bloque returns Variables
	 *
	 * Constraint:
	 *     (name=ID val=DataType_)
	 */
	protected void sequence_Variables(ISerializationContext context, Variables semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, CompilacionPackage.Literals.VARIABLES__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CompilacionPackage.Literals.VARIABLES__NAME));
			if (transientValues.isValueTransient(semanticObject, CompilacionPackage.Literals.VARIABLES__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, CompilacionPackage.Literals.VARIABLES__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariablesAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariablesAccess().getValDataType_ParserRuleCall_3_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
}
