/*
 * generated by Xtext 2.24.0
 */
package edu.upb.lp.isc.generator

import edu.upb.lp.isc.compilacion.Aritmetica
import edu.upb.lp.isc.compilacion.Bool
import edu.upb.lp.isc.compilacion.DataType_
import edu.upb.lp.isc.compilacion.Declaraciones
import edu.upb.lp.isc.compilacion.Ejecucion
import edu.upb.lp.isc.compilacion.Equal
import edu.upb.lp.isc.compilacion.Estructuras
import edu.upb.lp.isc.compilacion.Expr
import edu.upb.lp.isc.compilacion.FuncionSimplificada
import edu.upb.lp.isc.compilacion.List
import edu.upb.lp.isc.compilacion.MyInt
import edu.upb.lp.isc.compilacion.MyString
import edu.upb.lp.isc.compilacion.Operadores
import edu.upb.lp.isc.compilacion.Programa
import edu.upb.lp.isc.compilacion.Simple
import edu.upb.lp.isc.compilacion.Variables
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class CompilacionGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))
 	val a = resource.allContents.head as Programa
 	fsa.generateFile(a.name + ".cpp", generatePrograma(a))
	}
	
	
	
	def generatePrograma(Programa a) 
	'''
	#include <bits/stdc++.h>
	using namespace std;
	int main()
	{	    
	«FOR d: a.declaraciones»
	«generateDeclaraciones(d)»
	«ENDFOR»
	«FOR e: a.ejecuciones»
	«generateEjecucion(e)»
	«ENDFOR»
	}
	
	'''
	
	
	def generateEjecucion(Ejecucion e) 
	'''
	«IF e instanceof Expr» 
	cout<<«generateExpr(e as Expr)»<<endl;
	«ENDIF»
	'''
	
	
	
	def generateDeclaraciones(Declaraciones d) 
	'''
	«IF d instanceof Simple»
	«generateSimple(d as Simple)»
	«ENDIF»
	'''
	 
	 
	def generateSimple(Simple s)
	''' 
	«IF s instanceof Expr»
	«generateExpr(s as Expr)»
	«ELSEIF s instanceof Estructuras»
	«generateEstructuras(s as Estructuras)»
	«ENDIF»
	'''
	
	
	def generateExpr(Expr e)
	'''
	«IF e instanceof DataType_» 
	«generateDataType(e as DataType_)»
	«ELSEIF e instanceof Aritmetica»
	«generateAritmetica(e as Aritmetica)»
	«ELSEIF e instanceof Equal»
	«generateEqual(e as Equal)»
	«ELSEIF e instanceof Variables»
	«generateVariables(e as Variables)»
	«ELSEIF e instanceof FuncionSimplificada»
	«generateFuncionSimplificada(e as FuncionSimplificada)»
	«ENDIF»
	'''
	
	
	def generateDataType(DataType_ d) // TODO List
	'''
	«IF d instanceof MyInt »
	«val data = d as MyInt»
	«data.value»
	«ELSEIF d instanceof MyString»
	«val data = d as MyString»
	"«data.value»"
	«ELSEIF d instanceof Bool»
	«val data = d as Bool»
	«data.op»
	«ELSEIF d instanceof List» 
	«val data = d as List»
	[
	«»
	]
	«ENDIF»
	'''
	
	// cout<<"["<<dist[map['t']]<<"]";
	def generateAritmetica(Aritmetica a)
	'''
	«a.argument.map[value].join(generateOperadores(a.op))»
	'''
	
	
	def generateOperadores( Operadores o)
	'''
	«o.op»
	'''
	
	def generateEqual(Equal e)''''''
	def generateVariables(Variables v)''''''
	def generateFuncionSimplificada(FuncionSimplificada f)''''''
	def generateEstructuras(Estructuras e)''''''
	
	
	
	}
