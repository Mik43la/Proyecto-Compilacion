grammar edu.upb.lp.isc.Compilacion with org.eclipse.xtext.common.Terminals
generate compilacion "http://www.upb.edu/lp/isc/Compilacion"

//cond define else keywords
Programa: 
 	'Programa' name = ID 
	(declaraciones += Declaraciones)*
	(ejecuciones += Ejecucion)*
;

Ejecucion:
	'>' Expr
;

Declaraciones:
	Simple 
;

Simple:
	Expr | Estructuras | Variable
;

Expr:
	( Data | Aritmetica | Equal  | FuncionSimplificada | List_Cons_Operation )
;

Data:
	 ( MyInt | MyString | Bool | List | LlamarFuncion | Cons)
;
MyInt:
	value = INT
;
MyString:
	value = STRING
;

IsDataType: 
	('number?' | 'string?' | 'list?' ) Data //???? no se
;

Aritmetica:
	'('op = (Operadores|Boolean_Op) argument+=(Variable|Expr) argument+=(Variable|Expr)+')'  //revisar + - * / aceptan si es solo un int pero los obligaremos a que sea dos //PREGUNTAR llamar funciones
															//el problema es que expt quotient remainder solo aceptan dos INT
															//pd si quieres agregar double en ves de Int es number
;

Operadores:
	op = ('=' | '+' | '-' | '*' | '/' | 'expt' | 'quotient' | 'remainder')//revisar PREGUNTAR
;

Variable:
(  nombreaVar=ID  )  //supercheck
;

Boolean_Op: 
	op = ('<' | '>=' | '>' | '<=' )
;

Bool:
	value = ('#T' | '#F' | '#t' | '#f' | '#true' | '#false' | 'true' | 'false')
;

Estructuras:
	 If   //por ver
;	
//klajdafs ñ.ñ
Cons:
	//'(''cons' primer= (Data|Variable) segundo=(Data|Variable) ')'
	'(''cons' primer= (Expr|Variable) segundo=(Expr|Variable) ')'
;
List:
	 {List}	'(''list' data+=Data+')' 
	//{List}'(''list'  typeOfList = ( (INT)+ | (STRING)+ | (Bool)+ | (List)+ ) ')' 
;

List_Cons_Operation:
	'(' op = ('length'|'car'|'cdr'|'list-ref')  lYc = Simple')'//TODO
;

Atributo:// aun por ver creo que Ya No
	(atributoName=ID)
;

FuncionSimplificada: // aqui probablemente deberia ser una Variable 
//porque al definir Funciones le das variables como parametros
// bueno, probablemente esto se repeteria en todo
//al crear una funcion solo estas usando variables sin valores almacenados
//al llamar funcion se otorga valores\
	'(' 'define' '(' name=ID (parameter+=Variable)*')' '(' then=Bloque ')' ')'//revisar    PREGUNTAR
;

LlamarFuncion: 
	'(' nombreFuncion= [FuncionSimplificada] arguments+=(Expr|Variable)* ')'
;

Equal:
	'(' (('equal?' | 'eq?') data1=Data data2=Data) | (op=Boolean_Op data1=MyInt data2=MyInt)')'
	//revisar equal de listas co
	//n = no da con eq? da #f con equal? da #t podria hacer que en validation no deje usar equal si usa =
;

//BooleanExpression:
//	Boolean_Op expr1=Expr expr2=Expr  //no se para que es esto
//;

If://check
	'(' 
		'if' '(' condition = ( Equal | Aritmetica | LlamarFuncion)')'	
		('(') then = Bloque (')')
		 ('(' 'else' else = Bloque ')' )?
		
	')'
;

Bloque:
	Simple 
;
